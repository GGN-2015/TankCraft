# 通信协议

作者：仙仙行在，GGN_2015

本协议的初衷是设计一种兼顾通信效率和可拓展性的信息编码方式，游戏客户端与服务端中的相关实现逻辑也在本文档中给出了描述。

游戏采用采用纯粹的 C/S 模型，每次通信建议最大长度不低于 $TcpBufferMax=1048576$ Bytes，客户端提出请求，服务端给出对应的响应。在没有收到客户端发送来的消息时，服务端不会向客户端发送任何消息。

通信中的所有长度一定都是偶数个字节。

## 0. 一些约定

我们在协议设计上保证了所有的消息长度均为大于等于四的偶数，当客户端或者服务端接收到了长度不符合要求或者校验信息错误的消息，需要在错误输出流进行报错。在软件实现不出错的前提下，理应不会出现这种情况。

## 1. 客户端发送的请求 

客户端至多每隔 $TimeSpec=0.06s$ 向服务端发送一次消息，客户端使用一个线程专门负责和服务端交互。

### 1.1 总格式

校验信息是异或和，校验信息出错，断开和该客户端的连接。

```c
[请求数(2字节)] [请求1] [请求2] ... [请求n] [校验信息(2字节)]
```

### 1.2 单个请求格式

```c
[请求类型(2字节)] [长度(2字节)] [数据(长度由“长度”决定，内容由“请求类型”决定)]
```

### 1.3 各种请求类型

#### 1.3.0 可达性检验消息 PingRequest=PingMessage

```c
[请求类型=0] [长度=2] [0~65535的一个随机数 X]
```

意义是：防止客户端心跳超时被踢出。服务端要将 $X+1$ 恢复给客户端，以证明自己是“清醒的”。

#### 1.3.1 登录检验 LoginRequest

用于检验 登录名是否发生了重复，登录的长度小于等于 64，客户端进行截断。

用户登录名字符串使用宽字符字符串。（长度一定是偶数，编码方式 UTF-16）

```c
[请求类型=1] [长度="用户名的长度"向上取到偶数] [用户名字符串] 
```

#### 1.3.2 请求地图 MapRequest

```c
[请求类型=2] [长度=0]
```

服务端可能在客户端并没有请求地图信息的前提下，就向客户端发送了地图信息，表示地图的更改。

#### 1.3.3 请求用户信息

```c
[请求类型=3] [长度=0]
```

该请求用于拉取全部信息。

服务端为每一个客户端准备了一个线程，每个线程记录了一个整数 $MaxSentID$——表示曾经发送给该客户端过的最大的用户ID。

当服务端有新用户加入的时候，会检查所有线程的 $MaxSentID$，以决定是否发送这个用户的信息。客户端在接收到一个差分的用户信息消息时，可能已经对该用户进行了默认值填充，此时应该覆盖这个默认值。

当客户端接收到的坦克坐标信息少了某个人的坐标的时候，说明那个人下线了。（自己下线了，说明服务器有问题。）

#### 1.3.4 请求坦克的位置信息

服务端忽略客户端对坦克位置的请求。（虽然请求类型=4）

#### 1.3.5 请求击杀数信息

```c
[请求类型=5] [长度=0]
```

客户端会在登录成功后请求击杀数信息，击杀数信息中很可能包含自己不认识的 ID，此时需要使用默认值填充。服务端会在击杀数改变以及有人加入或退出时根据时间戳向客户端主动发送击杀数信息。

#### 1.3.6 请求修改按键状态

```c
[消息类型=6] [长度=2] [按键(1Byte))] [状态(1Byte)]
```

抽象按键编号：炮：0，右：1，上：2，左：3，下：4；状态：按下：0，抬起：1；

服务器会检查“上”“下”同时按下时不能运动，“左”“右”同理（服务端会对上下左右状态进行记录，会记录上次发炮的时间）。

客户端会记录每次发炮的时间，如果当前发炮 CD 未完成，不允许发炮，服务端也需要做 CD 检查。

#### 1.3.7 请求其他实体信息

服务端忽略客户端对其他实体信息的请求。（虽然请求类型=7）

## 2. 服务端反馈的消息

### 2.1 总格式

```c
[消息数(2字节)] [消息1] [消息2] ... [消息n] [校验信息(2字节)]
```

如果客户端发现校验信息不对，报错，退出游戏。

### 2.2 单个消息格式

 ```c
 [消息类型(2字节)] [长度(2字节)] [数据(长度由“长度”决定，内容由“消息类型”决定)]
 ```

### 2.3 各种消息类型

#### 2.3.-1 用于内部通信的可达性消息

```c
[消息类型=65535] [长度=2] [错误码]
```

错误码的含义：

- 0: 与服务端连接成功；
- 1: WSA 启动时出错；
- 2: 套接字对象建立时出错；
- 3: 连接不到服务器；
- 4: 已连接到服务器，但服务器断开了连接；

#### 2.3.0 可达性检验消息 PingRequest=PingMessage

```c
[消息类型=0] [长度=2] [(X + 1) % 65536]
```

整数加法采用 Short 类型自然溢出。

#### 2.3.1 登录检验消息 LoginMessage

```c
[消息类型=1] [长度=6] [错误码(2字节)] [用户ID(4字节)]
```

错误码的所有取值：

- 0：登录成功
- 1：服务器满员
- 2：登录名重复
- 3：服务器禁用了该 IP
- 4：发生了错误，但是服务端想保持“神秘感”

当前版本只实现了 0, 1, 2 三种错误。

#### 2.3.2 地图信息消息

要求高度和宽度必须是八的倍数。

```c
[消息类型=2] [数据部分长度：计算得到] [高度1字节] [宽度1字节] [高度*宽度*2 个 bit]
```

每两个 bit 对应一个格子的左面墙和上面墙是否存在：0：不存在，1：存在。

**一定要注意：对于一个字节中的信息，要从低位到高位使用。**

#### 2.3.3 用户信息消息

```c
[消息类型=3] [数据部分长度:计算得到] [用户数量 (2Byte)] [用户1信息] .. [用户n信息]
```

用户信息格式如下：

```c
[用户ID(4字节)] [登录名长度] [登录名字符串] [颜色RGBA(4字节)] [用户击杀数(2字节)]
```

实际上 A 的值我们并不考虑，因为无敌时间内，玩家是半透明的。

#### 2.3.4 坦克位置消息

服务端每次向客户端发送消息，都一定会带有坦克位置信息。

```c
[消息类型=4] [数据部分长度：计算得到] [总坦克数(2Byte)] [每个坦克的ID/位置/方向/状态(18Bytes)]
```

注：客户端接收到的坦克位置信息可能包含着客户端“不认识”的坦克（客户端还没有见过这个 ID）。

处理方式：接收的时候填写默认的颜色，填写一个默认的用户名，击杀数默认为 0。

#### 2.3.5 击杀数信息

一定会发送击杀排行榜的全文。如果当前玩家是一个观战玩家，那么击杀数为零。

```c
[消息类型=5] [数据部分长度:计算得到] [当前玩家的击杀数(2字节)] [min{坦克数量，排行榜人数}] [击杀信息1] ... [击杀信息n]
```

击杀信息为：

```c
[用户ID(4Bytes)] [击杀数（2字节）]
```

服务器按照击杀数为第一关键字，用户 ID 为第二关键字排序，击杀数变化的时候进行冒泡排序。对于杀数与退出记录一个时间戳，对于每一个为客户端服务的线程，记录一个时间戳。当两个时间戳之中，击杀数的时间戳比线程时间戳更新，则服务器要主动向客户端发送一个击杀数消息（尽管客户端可能并没有这个请求）。

#### 2.3.6 按键反馈信息

一般情况下不会发送这种消息（默认所有的客户端的按键操作都能被服务端正确处理）。

#### 2.3.7 其他实体信息

服务端每次向客户端发送消息，都一定会带有其他实体信息。

```c
[消息类型=7] [数据部分长度:计算得到] [实体数量] [实体1信息] ... [实体n信息]
```

实体类型：

- 0: 炮弹 (需要记录实体编号)
- 1: 坦克残骸（播放爆炸动画，UID：决定颜色）
- 2: 激光
- 3: 武器获取地点

##### 2.3.7.0 炮弹

$x$ 方向向下，$y$ 方向向右，所有数据均采用 ``float`` 类型。炮弹的实体编号可以重复使用。

前端时候插值算法确定炮弹飞行的方向和速度，后端物理引擎需要记录坦克速度，但是并不发送给前端。

```c
[实体类型=0] [坐标(x,y)8字节] [实体编号2字节]
```

##### 2.3.7.1 坦克残骸

用户 ID 主要用于确定颜色。

```c
[实体类型=1] [坐标(x,y)8字节] [用户ID(4字节)]
```

##### 2.3.7.2 激光

服务端的实体管理器在检测到有激光出现时会直接给每个客户端的发送缓冲中增加一个激光实体信息。（注意并发 bug 和死锁。）

```c
[实体类型=2] [坐标点个数2字节] [坐标1] .. [坐标n]
```

