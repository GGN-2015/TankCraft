# 通信协议

采用 C/S 模型，每次通信建议最大长度不低于 $1048576$ Bytes，客户端提出请求，服务端给出对应的响应。

通信中的所有长度一定都是偶数个字节。

## 1. 客户端发送的请求

### 1.1 总格式

校验信息是异或和，校验信息出错，断开和该客户端的连接。

```c
[请求数(2字节)] [请求1] [请求2] ... [请求n] [校验信息(2字节)]
```

### 1.2 单个请求格式

```c
[请求类型(2字节)] [长度(2字节)] [数据(长度由“长度”决定，内容由“请求类型”决定)]
```

### 1.3 各种请求类型

#### 1.3.0 可达性检验消息

```c
[请求类型=0] [长度=2] [0~65535的一个随机数 X]
```

意义是：防止客户端心跳超时被踢出。服务端要将 $X+1$ 恢复给客户端，以证明自己是“清醒的”。

#### 1.3.1 登录检验

用于检验 登录名是否发生了重复，登录的长度小于等于 64，客户端进行截断。

用户登录名字符串使用宽字符字符串。（长度一定是偶数，编码方式 UTF-16）

```c
[请求类型=1] [长度="用户名的长度"向上取到偶数] [用户名字符串] 
```

#### 1.3.2 请求地图

```c
[请求类型=2] [长度=0]
```

服务端可能在客户端并没有请求地图信息的前提下，就向客户端发送了地图信息，表示地图的更改。

#### 1.3.3 请求用户信息

```c
[请求类型=3] [长度=0]
```

该请求用于拉取全部信息。

服务端为每一个客户端准备了一个线程，每个线程记录了一个整数 $MaxSentID$——表示曾经发送给该客户端过的最大的用户ID。

当服务端有新用户加入的时候，会检查所有线程的 $MaxSentID$，以决定是否发送这个用户的信息。客户端在接收到一个差分的用户信息消息时，可能已经对该用户进行了默认值填充，此时应该覆盖这个默认值。

当客户端接收到的坦克坐标信息少了某个人的坐标的时候，说明那个人下线了。（自己下线了，说明服务器有问题。）

#### 1.3.4 请求坦克的位置信息

**可能需要进一步优化。**

```c
[请求类型=4] [长度=0]
```

服务端接收到该请求后会向客户端发送所有仍然在线的坦克的位置和方向。

客户端需要根据这个消息确定哪些玩家已经下线。

#### 1.3.5 请求击杀数信息

```c
[请求类型=5] [长度=0]
```

客户端会在登录成功后请求击杀数信息，击杀数信息中很可能包含自己不认识的 ID，此时需要使用默认值填充。服务端会在击杀数改变以及有人加入或退出时根据时间戳向客户端主动发送击杀数信息。

#### 1.3.6 发送按键状态

```c
[消息类型=6] [长度=2] [按键(1Byte))] [状态(1Byte)]
```

抽象按键编号：炮：0，右：1，上：2，左：3，下：4；状态：按下：0，抬起：1；

服务器会检查“上”“下”同时按下时不能运动，“左”“右”同理（服务端会对上下左右状态进行记录，会记录上次发炮的时间）。

客户端会记录每次发炮的时间，如果当前发炮 CD 未完成，不允许发炮，服务端也需要做 CD 检查。

## 2. 服务端反馈的消息

### 2.1 总格式

```c
[消息数(2字节)] [消息1] [消息2] ... [消息n] [校验信息(2字节)]
```

如果客户端发现校验信息不对，报错，退出游戏。

### 2.2 单个消息格式

 ```c
 [消息类型(2字节)] [长度(2字节)] [数据(长度由“长度”决定，内容由“消息类型”决定)]
 ```

### 2.3 各种消息类型

#### 2.3.0 可达性检验消息

```c
[消息类型=0] [长度=2] [(X + 1) % 65536]
```

整数加法采用 Short 类型自然溢出。

#### 2.3.1 登录检验消息

```c
[消息类型=1] [长度=2] [错误码(2个字节)]
```

错误码的所有取值：

- 0：登录成功
- 1：服务器满员
- 2：登录名重复
- 3：服务器禁用了该 IP
- 4：发生了错误，但是服务端想保持“神秘感”

#### 2.3.2 地图信息消息

要求高度和宽度必须是四的倍数。

```c
[消息类型=2][高度1字节] [宽度1字节] [高度*宽度*2 个 bit]
```

每两个 bit 对应一个格子的左面墙和上面墙是否存在：0：不存在，1：存在。

**一定要注意：对于一个字节中的信息，要从低位到高位使用。**

#### 2.3.3 用户信息消息

```c
[消息类型=3] [长度: 经过计算得到] [用户数量 (2Byte)] [用户1信息] .. [用户n信息]
```

用户信息格式如下：

```c
[用户ID(4字节)] [登录名长度] [登录名字符串] [颜色RGBA(4字节)] [用户击杀数(2字节)]
```

实际上 A 的值我们并不考虑，因为无敌时间内，玩家是半透明的。

#### 2.3.4 坦克位置消息

```c
[消息类型=4] [总坦克数(2Byte)] [每个坦克的ID/位置/方向/状态(18Bytes)]
```

注：客户端接收到的坦克位置信息可能包含着客户端“不认识”的坦克（客户端还没有见过这个 ID）。

处理方式：接收的时候填写默认的颜色，填写一个默认的用户名，击杀数默认为 0。

#### 2.3.5 击杀数信息

```c
[消息类型=5] [min{总坦克数量，排行榜最大人数}] [击杀信息1] ... [击杀信息n]
```

击杀信息为：

```c
[用户ID(4Bytes)] [击杀数（2字节）]
```

服务器按照击杀数为第一关键字，用户 ID 为第二关键字排序，击杀数变化的时候进行冒泡排序。对于杀数与退出记录一个时间戳，对于每一个为客户端服务的线程，记录一个时间戳。当两个时间戳之中，击杀数的时间戳比线程时间戳更新，则服务器要主动向客户端发送一个击杀数消息（尽管客户端可能并没有这个请求）。

